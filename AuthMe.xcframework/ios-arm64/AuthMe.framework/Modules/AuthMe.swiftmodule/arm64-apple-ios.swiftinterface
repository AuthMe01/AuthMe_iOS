// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.10 (swiftlang-5.10.0.13 clang-1500.3.9.4)
// swift-module-flags: -target arm64-apple-ios13.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -enable-bare-slash-regex -module-name AuthMe
import Algo
@_exported import AuthMe
import CoreGraphics/*.CGFloat*/
import CoreGraphics/*.CGSize*/
import CryptoKit
import Foundation
import MobileCoreServices
import Security
import Swift
import UIKit.UIImage
import UIKit
import UIKit/*.UIEdgeInsets*/
import UIKit/*.UIImage*/
import Vision
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
extension Swift.Array where Element : Swift.Equatable {
  public mutating func mergeElements<C>(newElements: C) where Element == C.Element, C : Swift.Collection
}
public struct AuthMeConfig {
  public static var `default`: AuthMe.AuthMeConfig {
    get
  }
  public var activateCertificate: Swift.String
  public var activateToken: Swift.String
  public var serverURL: Foundation.URL
  public var sslCredentials: [AuthMe.AuthMeConfig.SSLCredential]?
  public struct SSLCredential {
    public let host: Swift.String
    public let credentialURL: Foundation.URL
    public init(host: Swift.String, credentialURL: Foundation.URL)
  }
}
@_hasMissingDesignatedInitializers public class AuthMeCore<T> where T : AuthMe.FrameworkMode {
  public static var version: Swift.String {
    get
  }
  public static var buildNumber: Swift.String {
    get
  }
  @objc deinit
}
public struct LogFAS {
  public enum LogStage {
    case Passive
    case OpenMouth
    case CloseMouth
    case Smile
    case Scale
    case Done
    public static func == (a: AuthMe.LogFAS.LogStage, b: AuthMe.LogFAS.LogStage) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum LogFASResult {
    case Failed
    case NoFace
    case FaceNotAtCenter
    case FaceTooSmall
    case FaceTooLarge
    case NeedFaceToCamera
    case FaceMasked
    case NeedOpenMouth
    case NeedCloseMouth
    case NeedSmile
    case NeedOpenEyes
    case NeedMoreFrame
    case Error
    case Pass
    public static func == (a: AuthMe.LogFAS.LogFASResult, b: AuthMe.LogFAS.LogFASResult) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let logStage: AuthMe.LogFAS.LogStage
  public let logFASResult: AuthMe.LogFAS.LogFASResult
  public init(logStage: AuthMe.LogFAS.LogStage, logFASResult: AuthMe.LogFAS.LogFASResult)
}
public struct LogUpload {
  public enum Event {
    case start
    case end
    public static func == (a: AuthMe.LogUpload.Event, b: AuthMe.LogUpload.Event) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let duration: Swift.String
  public let event: AuthMe.LogUpload.Event
  public let frameNo: Swift.String
  public init(duration: Swift.String = "0", event: AuthMe.LogUpload.Event, frameNo: Swift.String)
}
public enum LivenessDetectStatus {
  case Failed
  case NoFace
  case FaceNotAtCenter
  case FaceTooSmall
  case FaceTooLarge
  case NeedFaceToCamera
  case FaceMasked
  case NeedOpenMouth
  case NeedCloseMouth
  case NeedOpenEyes
  case NeedSmile
  case NeedMoreFrame
  case Pass
  case Error
  case Empty
  public static func == (a: AuthMe.LivenessDetectStatus, b: AuthMe.LivenessDetectStatus) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol LivenessFlowDelegate : AnyObject {
  func livenessDidStart()
  func livenessDidNotifyMessage(status: AuthMe.LivenessDetectStatus)
  func livenessDidUpdateReconize(result: Swift.Bool)
  func livenessDidFailureWith(error: AuthMe.FlowError, retryHandler: @escaping (() -> Swift.Void))
  func livenessDidRecognize(image: UIKit.UIImage)
  func livenessDidFaceScale(direction: AuthMe.LivenessFlow.FaceScaleDirection.Direction)
  func livenessNotifyStage(log: AuthMe.LogFAS)
  func livenessNotifyUpload(log: AuthMe.LogUpload)
}
public class LivenessFlow : AuthMe.LivenessFlowProtocol {
  public func setDelegate(_ delegate: any AuthMe.LivenessFlowDelegate)
  weak public var delegate: (any AuthMe.LivenessFlowDelegate)?
  public var isDetecting: Swift.Bool {
    get
  }
  public init(action: AuthMe.Action = .register(waitResult: true))
  @objc deinit
  public func checkModel(progressHandler: ((Swift.Double) -> Swift.Void)? = nil, handler: ((Swift.Result<Swift.Void, AuthMe.FlowError>) -> Swift.Void)?)
  public func setPreviewSize(previewSize: CoreFoundation.CGSize)
  public func start(encrypt: Swift.Bool)
  public func recognize(image: UIKit.UIImage)
  public func recognize(normal normalImage: UIKit.UIImage, depthImage: UIKit.UIImage)
  public func roiRect(in previewSize: CoreFoundation.CGSize) -> CoreFoundation.CGRect
  public func cancelExpired()
  public func getResult(completion: @escaping ((Swift.Bool) -> Swift.Void))
  public func isExpired() -> Swift.Bool
  public func getVerifyResult(completion: @escaping ((Swift.Bool) -> Swift.Void))
  public func enableUploadFullFrame()
}
extension AuthMe.LivenessFlow {
  public struct RoiParam {
    public init(preview: AuthMe.EnginePreview, ratio: CoreFoundation.CGFloat, widthRatio: CoreFoundation.CGFloat, offset: UIKit.UIOffset)
  }
  public struct FaceScaleDirection {
    public enum Direction {
      case small
      case normal
      public static func == (a: AuthMe.LivenessFlow.FaceScaleDirection.Direction, b: AuthMe.LivenessFlow.FaceScaleDirection.Direction) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
  }
}
extension AuthMe.AuthMeCore where T == AuthMe.OfflineMode {
  public static func configure() -> AuthMe.AuthmeCoreOfflineBuilder
}
public protocol Cancellable : AnyObject {
  var isCancelled: Swift.Bool { get }
  func cancel()
}
extension CoreFoundation.CGRect {
  public var center: CoreFoundation.CGPoint {
    get
  }
}
extension CoreFoundation.CGRect {
  public init(center: CoreFoundation.CGPoint, size: CoreFoundation.CGSize)
}
extension CoreFoundation.CGRect {
  public func resizing(to size: CoreFoundation.CGSize, anchor: CoreFoundation.CGPoint = CGPoint(x: 0.5, y: 0.5)) -> CoreFoundation.CGRect
}
extension Swift.Collection {
  public subscript(safe index: Self.Index) -> Self.Element? {
    get
  }
  public func group(by size: Swift.Int) -> [[Self.Element]]?
}
extension Swift.Collection where Self.Element : Swift.BinaryInteger {
  public func average() -> Swift.Double
}
extension Swift.Collection where Self.Element : Swift.FloatingPoint {
  public func average() -> Self.Element
}
extension AuthMe.AuthMeCore where T == AuthMe.OnlineMode {
  public static func configure() -> AuthMe.AuthmeCoreOnlineBuilder
  public static func replaceAccessToken(_ accessToken: Swift.String) throws
}
extension Swift.Dictionary {
  public mutating func removeAll<S>(keys: S) where Key == S.Element, S : Swift.Sequence
  public func has(key: Key) -> Swift.Bool
  public static func + (lhs: [Key : Value], rhs: [Key : Value]) -> [Key : Value]
  public static func += (lhs: inout [Key : Value], rhs: [Key : Value])
  public static func - <S>(lhs: [Key : Value], keys: S) -> [Key : Value] where Key == S.Element, S : Swift.Sequence
  public static func -= <S>(lhs: inout [Key : Value], keys: S) where Key == S.Element, S : Swift.Sequence
}
public struct EnginePreview {
  public init(imageSize: CoreFoundation.CGSize, previewSize: CoreFoundation.CGSize, previewInsets: UIKit.UIEdgeInsets = .zero)
}
public struct ErrorDescription : Foundation.LocalizedError, Swift.Equatable {
  public init(description: Swift.String)
  public var localizedDescription: Swift.String {
    get
  }
  public static func == (a: AuthMe.ErrorDescription, b: AuthMe.ErrorDescription) -> Swift.Bool
}
extension AuthMe.ErrorDescription : Swift.ExpressibleByStringLiteral {
  public init(stringLiteral value: Swift.String)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias StringLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
public struct StatusCodeError : Swift.Error {
  public let localizedDescription: Swift.String
}
public func decode(jwt: Swift.String) throws -> any AuthMe.JWT
public struct Claim {
  public var rawValue: Any? {
    get
  }
  public var string: Swift.String? {
    get
  }
  public var boolean: Swift.Bool? {
    get
  }
  public var double: Swift.Double? {
    get
  }
  public var integer: Swift.Int? {
    get
  }
  public var date: Foundation.Date? {
    get
  }
  public var array: [Swift.String]? {
    get
  }
}
@dynamicMemberLookup public struct Fluent<Subject> {
  public let subject: Subject
  public subscript<Value>(dynamicMember keyPath: Swift.WritableKeyPath<Subject, Value>) -> ((Value) -> AuthMe.Fluent<Subject>) {
    get
  }
  public func set<Value>(_ keyPath: Swift.WritableKeyPath<Subject, Value>, _ value: Value) -> AuthMe.Fluent<Subject>
}
@dynamicMemberLookup public struct ObjectFluent<Subject> where Subject : AnyObject {
  public let subject: Subject
  public subscript<Value>(dynamicMember keyPath: Swift.ReferenceWritableKeyPath<Subject, Value>) -> ((Value) -> AuthMe.ObjectFluent<Subject>) {
    get
  }
  @discardableResult
  public func set<Value>(_ keyPath: Swift.ReferenceWritableKeyPath<Subject, Value>, _ value: Value) -> AuthMe.ObjectFluent<Subject>
  public func cauterize()
}
postfix operator +
postfix public func + <T>(lhs: T) -> AuthMe.Fluent<T>
postfix public func + <T>(lhs: T) -> AuthMe.ObjectFluent<T> where T : AnyObject
postfix operator -
postfix public func - <T>(lhs: AuthMe.Fluent<T>) -> T
@discardableResult
postfix public func - <T>(lhs: AuthMe.ObjectFluent<T>) -> T where T : AnyObject
@_hasMissingDesignatedInitializers public class OfflineMode : AuthMe.FrameworkMode {
  @objc deinit
}
@objc @_inheritsConvenienceInitializers public class AuthmeCoreOfflineBuilder : ObjectiveC.NSObject {
  public func setConfig(_ config: AuthMe.AuthMeConfig) -> AuthMe.AuthmeCoreOfflineBuilder
  public func setModelPaths(_ paths: [Swift.String]) -> AuthMe.AuthmeCoreOfflineBuilder
  public func build() -> Swift.Result<Swift.Void, any Swift.Error>
  @objc override dynamic public init()
  @objc deinit
}
public enum LogAntiFraud : Swift.String {
  case Failed
  case NoCard
  case WrongCardType
  case Reflective
  case Blur
  case Gray
  case PositionNotMatch
  case NeedMoreFrame
  case Pass
  case Error
  case none
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
@frozen public enum AuthmeOCRResult<Success, Temporariness, Failure> where Failure : Swift.Error {
  case success(Success)
  case temporariness(Temporariness)
  case failure(Failure)
}
public struct SessionInfo {
}
public enum OCRCardType : Swift.String, Swift.Codable {
  case TWID
  case TWLicense
  case TWHealth
  case Passport
  case Passport_NFC
  case TWNResident
  case JPNID
  case JPNDriverLicense
  case JPNResidentCard
  case USAID
  case USADriverLicense
  case USAVisitorVISA
  case IDNID
  case IDNDriverLicense
  case INDID
  case INDDriverLicense
  case MYSID
  case MYSDriverLicense
  case HKGID
  case HKGIDFront
  case HKGDriverLicense
  case GBRID
  case GBRDriverLicense
  case EGYID
  case EGYDriverLicense
  case SAUID
  case SAUDriverLicense
  case NLDID
  case NLDDriverLicense
  case SGPID
  case SGPDriverLicense
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum OCRType : Swift.String, Swift.Codable {
  case TWN_IDCard_Front
  case TWN_IDCard_Back
  case TWN_DriverLicense_Front
  case TWN_DriverLicense_Back
  case TWN_HealthCard_Front
  case Passport
  case Passport_NFC
  case TWN_ResidentCard_Front
  case TWN_ResidentCard_Back
  case JPN_IDCard_Front
  case JPN_IDCard_Back
  case JPN_IDCard_NFC
  case JPN_IDCard_Thickness
  case JPN_DriverLicense_Front
  case JPN_DriverLicense_Back
  case JPN_DriverLicense_NFC
  case JPN_DriverLicense_Thickness
  case JPN_ResidentCard_Front
  case JPN_ResidentCard_Back
  case JPN_ResidentCard_Thickness
  case JPN_ResidentCard_NFC
  case USA_IDCard_Front
  case USA_DriverLicense_Front
  case USA_VisitorVISA_Front
  case IDN_IDCard_Front
  case IDN_IDCard_Back
  case IDN_DriverLicense_Front
  case IND_IDCard_Front
  case IND_IDCard_Back
  case IND_DriverLicense_Front
  case MYS_IDCard_Front
  case MYS_IDCard_Back
  case MYS_DriverLicense_Front
  case HKG_IDCard_Front
  case HKG_IDCard_Back
  case HKG_DriverLicense_Front
  case GBR_IDCard_Front
  case GBR_DriverLicense_Front
  case GBR_DriverLicense_Back
  case EGY_IDCard_Front
  case EGY_IDCard_Back
  case EGY_DriverLicense_Front
  case SAU_IDCard_Front
  case SAU_IDCard_Back
  case SAU_DriverLicense_Front
  case NLD_IDCard_Front
  case NLD_DriverLicense_Front
  case SGP_IDCard_Front
  case SGP_IDCard_Back
  case SGP_DriverLicense_Front
  case UnknownCard
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum OCRError : Swift.String, Foundation.LocalizedError {
  case ERROR_NETWORK
  case ERROR_RESPONSE
  case ERROR_SYSTEM_BUSY
  case ERROR_401
  case NO_DETECTED
  case CARD_REFLECTIVE
  case LOW_SHARPNESS
  case WORNG_CARD_TYPE
  case CARD_NOT_IN_REGION
  case CARD_TOO_SMALL
  case CARD_CUT_BY_CAMERA
  case PROCESS_FAIL
  case ERROR_VERCIAL
  case EXPIRED
  case EngineError
  case ERROR_EVENTNAME
  case ERROR_NEED_HOLD_CARD
  case DEFORMATION_LEFT
  case DEFORMATION_RIGHT
  case DEFORMATION_UP
  case DEFORMATION_DOWN
  case CARD_THICKNESS_FAILED
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct OCRFinishScanDocRequest {
}
public protocol OCRFlowDelegate : AnyObject {
  func didFailureWith(error: AuthMe.OCRError, retryHandler: @escaping (() -> Swift.Void))
  func notifyAntiFraudWith(status: AuthMe.LogAntiFraud)
}
public enum OCRNotifyMessage : Swift.String {
  case SUCCESS_SEGMENTATION
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public protocol DebugOCRFlowDelegate : AnyObject {
  func debugMessage(channel: AuthMe.DebugMessageChannel, message: Swift.String)
}
public enum DebugMessageChannel {
  case text
  case value
  case fail
  public static func == (a: AuthMe.DebugMessageChannel, b: AuthMe.DebugMessageChannel) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct OCRInitScanDocResponse : Swift.Decodable {
  public let scanView: AuthMe.OCRInitScanDocResponse.OCRScanView?
  public struct OCRScanView : Swift.Decodable {
    public let border: AuthMe.OCRInitScanDocResponse.OCRScanView.OCRScanViewBorder
    public let content: [AuthMe.OCRInitScanDocResponse.OCRScanView.OCRScanViewContent]
    public let success: AuthMe.OCRInitScanDocResponse.OCRScanView.OCRScanViewSuccessParameters
    public let line: AuthMe.OCRInitScanDocResponse.OCRScanView.OCRScanViewLine
    public struct OCRScanViewBorder : Swift.Decodable {
      public let enable: Swift.Bool
      public let type: AuthMe.OCRInitScanDocResponse.OCRScanView.OCRScanViewBorder.OCRScanViewBorderType
      public let color: Swift.String
      public let opacity: CoreFoundation.CGFloat
      public enum OCRScanViewBorderType : Swift.String, Swift.Decodable {
        case cornered
        case bordered
        public init?(rawValue: Swift.String)
        public typealias RawValue = Swift.String
        public var rawValue: Swift.String {
          get
        }
      }
      public init(from decoder: any Swift.Decoder) throws
    }
    public struct OCRScanViewContent : Swift.Decodable {
      public let type: AuthMe.OCRInitScanDocResponse.OCRScanView.OCRScanViewContent.OCRScanViewContentType
      public let content: Swift.String
      public let color: Swift.String?
      public let opacity: CoreFoundation.CGFloat
      public var imageData: Foundation.Data?
      public enum OCRScanViewContentType : Swift.String, Swift.Decodable {
        case text
        case pdf
        case svg
        public init?(rawValue: Swift.String)
        public typealias RawValue = Swift.String
        public var rawValue: Swift.String {
          get
        }
      }
      public init(from decoder: any Swift.Decoder) throws
    }
    public struct OCRScanViewSuccessParameters : Swift.Decodable {
      public let enable: Swift.Bool
      public let color: Swift.String
      public let opacity: CoreFoundation.CGFloat
      public init(from decoder: any Swift.Decoder) throws
    }
    public struct OCRScanViewLine : Swift.Decodable {
      public let enable: Swift.Bool
      public let color: Swift.String
      public let gradient: AuthMe.OCRInitScanDocResponse.OCRScanView.OCRScanViewLine.OCRScanViewLineGradient
      public struct OCRScanViewLineGradient : Swift.Decodable {
        public let enable: Swift.Bool
        public let color: Swift.String
        public let opacity: CoreFoundation.CGFloat
        public init(from decoder: any Swift.Decoder) throws
      }
      public init(from decoder: any Swift.Decoder) throws
    }
    public init(from decoder: any Swift.Decoder) throws
  }
  public init(from decoder: any Swift.Decoder) throws
}
public protocol EKYCType : Swift.Hashable, Swift.RawRepresentable where Self.RawValue == Swift.String {
}
extension AuthMe.EKYCType {
  public static func == (lhs: Self, rhs: Self) -> Swift.Bool
}
public protocol OCRResult {
  var fileID: Swift.String { get }
  var scanID: Swift.String { get }
  var data: [Swift.String : Swift.String] { get }
  var confirmedData: [Swift.String : Swift.String] { get }
  var frontImage: UIKit.UIImage? { get }
  var backImage: UIKit.UIImage? { get }
  var frontCropImage: UIKit.UIImage? { get }
  var backCropImage: UIKit.UIImage? { get }
  func confirmScan(complete: @escaping ((any Swift.Error)?) -> Swift.Void)
  func orderedData() -> [(Swift.String, Swift.String)]
  func set(key: Swift.String, value: Swift.String)
}
@_hasMissingDesignatedInitializers public class OCRBaseResult<DataType> : AuthMe.OCRResult where DataType : Swift.RawRepresentable, DataType.RawValue == Swift.String {
  final public let data: [Swift.String : Swift.String]
  public var confirmedData: [Swift.String : Swift.String]
  final public let frontImage: UIKit.UIImage?
  final public let backImage: UIKit.UIImage?
  public var frontCropImage: UIKit.UIImage?
  public var backCropImage: UIKit.UIImage?
  final public let isAuto: Swift.Bool
  final public let fileID: Swift.String
  public var scanID: Swift.String
  public func orderedData() -> [(Swift.String, Swift.String)]
  public func get(type: DataType) -> Swift.String
  public func set(type: DataType, value: Swift.String)
  public func set(key: Swift.String, value: Swift.String)
  public func confirmScan(complete: @escaping ((any Swift.Error)?) -> Swift.Void)
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class MRZResult : AuthMe.OCRBaseResult<AuthMe.MRZResult.DataType> {
  public enum DataType : Swift.String, Swift.CaseIterable {
    case surname
    case givenName
    case country
    case nationality
    case dateOfBirth
    case expiryDate
    case gender
    case documentType
    case documentNumber
    case idNumber
    case placeOfBirth
    case authority
    case dateOfIssue
    case fullName
    case otherName
    case documentNumberCheckDigit
    case birthDateCheckDigit
    case expiryDateCheckDigit
    case optionaldataCheckDigit
    case overallCheckDigit
    public init?(rawValue: Swift.String)
    public typealias AllCases = [AuthMe.MRZResult.DataType]
    public typealias RawValue = Swift.String
    public static var allCases: [AuthMe.MRZResult.DataType] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  convenience public init(data: [Swift.String : Swift.String], image: UIKit.UIImage?)
  public func setScanID(_ scanID: Swift.String)
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class TWNResidentResult : AuthMe.OCRBaseResult<AuthMe.TWNResidentResult.DataType> {
  public enum DataType : Swift.String, Swift.CaseIterable {
    case address
    case authority
    case country
    case dateOfBirth
    case dateOfIssue
    case expiryDate
    case fullName
    case gender
    case givenName
    case idNumber
    case middleName
    case name
    case nationality
    case otherName
    case passportNumber
    case placeOfBirth
    case surname
    public init?(rawValue: Swift.String)
    public typealias AllCases = [AuthMe.TWNResidentResult.DataType]
    public typealias RawValue = Swift.String
    public static var allCases: [AuthMe.TWNResidentResult.DataType] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  convenience public init(data: [Swift.String : Swift.String], image: UIKit.UIImage?)
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class TWIDResult : AuthMe.OCRBaseResult<AuthMe.TWIDResult.DataType> {
  override public func get(type: AuthMe.TWIDResult.DataType) -> Swift.String
  public enum DataType : Swift.String, Swift.CaseIterable {
    case militaryService
    case birth
    case issueCity
    case gender
    case issueReason
    case father
    case name
    case issueDate
    case placeOfBirth
    case spouse
    case mother
    case idNumber
    case address
    case nationality
    case serialNumber
    public init?(rawValue: Swift.String)
    public typealias AllCases = [AuthMe.TWIDResult.DataType]
    public typealias RawValue = Swift.String
    public static var allCases: [AuthMe.TWIDResult.DataType] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class TWLicenseResult : AuthMe.OCRBaseResult<AuthMe.TWLicenseResult.DataType> {
  override public func get(type: AuthMe.TWLicenseResult.DataType) -> Swift.String
  public enum DataType : Swift.String, Swift.CaseIterable {
    case name
    case condition
    case controlNo
    case gender
    case address
    case birth
    case issue
    case type
    case licenseNo
    case expiry
    case nationality
    public init?(rawValue: Swift.String)
    public typealias AllCases = [AuthMe.TWLicenseResult.DataType]
    public typealias RawValue = Swift.String
    public static var allCases: [AuthMe.TWLicenseResult.DataType] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class TWHealthResult : AuthMe.OCRBaseResult<AuthMe.TWHealthResult.DataType> {
  override public func get(type: AuthMe.TWHealthResult.DataType) -> Swift.String
  public enum DataType : Swift.String, Swift.CaseIterable {
    case name
    case dateOfBirth
    case idNumber
    case nationality
    case documentNumber
    public init?(rawValue: Swift.String)
    public typealias AllCases = [AuthMe.TWHealthResult.DataType]
    public typealias RawValue = Swift.String
    public static var allCases: [AuthMe.TWHealthResult.DataType] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class JPNIDCardResult : AuthMe.OCRBaseResult<AuthMe.JPNIDCardResult.DataType> {
  override public func get(type: AuthMe.JPNIDCardResult.DataType) -> Swift.String
  public enum DataType : Swift.String, Swift.CaseIterable {
    case name
    case address
    case gender
    case dateOfBirth
    case expiryDate
    case idNumber
    case age
    public init?(rawValue: Swift.String)
    public typealias AllCases = [AuthMe.JPNIDCardResult.DataType]
    public typealias RawValue = Swift.String
    public static var allCases: [AuthMe.JPNIDCardResult.DataType] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class JPNIDCardNFCResult : AuthMe.OCRBaseResult<AuthMe.JPNIDCardNFCResult.DataType> {
  override public func get(type: AuthMe.JPNIDCardNFCResult.DataType) -> Swift.String
  public enum DataType : Swift.String, Swift.CaseIterable {
    case name
    case address
    case gender
    case dateOfBirth
    case idNumber
    case expiryDate
    public init?(rawValue: Swift.String)
    public typealias AllCases = [AuthMe.JPNIDCardNFCResult.DataType]
    public typealias RawValue = Swift.String
    public static var allCases: [AuthMe.JPNIDCardNFCResult.DataType] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  convenience public init(data: [Swift.String : Swift.String], image: UIKit.UIImage)
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class JPNDriverLicenseResult : AuthMe.OCRBaseResult<AuthMe.JPNDriverLicenseResult.DataType> {
  override public func get(type: AuthMe.JPNDriverLicenseResult.DataType) -> Swift.String
  public enum DataType : Swift.String, Swift.CaseIterable {
    case name
    case dateOfBirth
    case address
    case dateOfIssue
    case expiryDate
    case documentNumber
    case age
    public init?(rawValue: Swift.String)
    public typealias AllCases = [AuthMe.JPNDriverLicenseResult.DataType]
    public typealias RawValue = Swift.String
    public static var allCases: [AuthMe.JPNDriverLicenseResult.DataType] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class JPNDriverLicenseNFCResult : AuthMe.OCRBaseResult<AuthMe.JPNDriverLicenseNFCResult.DataType> {
  override public func get(type: AuthMe.JPNDriverLicenseNFCResult.DataType) -> Swift.String
  public enum DataType : Swift.String, Swift.CaseIterable {
    case address
    case cardManufacturerIdentifier
    case class2LicenceDate
    case class2HeavyVehicleLicenceDate
    case class2HeavySpecialVehicleLicenceDate
    case class2MediumVehicleLicenceDate
    case class2OrdinaryVehicleLicenceDate
    case class2TrailerLicenceDate
    case color
    case commonName
    case condition1
    case condition2
    case condition3
    case condition4
    case cryptographicFunctionIdentifier
    case dateOfBirth
    case documentNumber
    case expiryDate
    case heavyMotorcycleLicenceDate
    case heavySpecialVehicleLicenceDate
    case heavyVehicleLicenceDate
    case dateOfIssue
    case issuingAuthority
    case jisX0208EstablishmentYearNumber
    case mediumVehicleLicenceDate
    case mopedLicenceDate
    case motorcycleLicenceDate
    case name
    case kanaName
    case ordinaryMotorcycleLicenceDate
    case ordinaryVehicleLicenceDate
    case otherLicenceDate
    case referenceNumber
    case registeredDomicile
    case semiMediumVehicleLicenceDate
    case smallSpecialVehicleLicenceDate
    case specificationVersionNumber
    case trailerLicenceDate
    case uniformName
    public init?(rawValue: Swift.String)
    public typealias AllCases = [AuthMe.JPNDriverLicenseNFCResult.DataType]
    public typealias RawValue = Swift.String
    public static var allCases: [AuthMe.JPNDriverLicenseNFCResult.DataType] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  convenience public init(data: [Swift.String : Swift.String], image: UIKit.UIImage?)
  public func setScanID(_ scanID: Swift.String)
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class JPNResidentCardResult : AuthMe.OCRBaseResult<AuthMe.JPNResidentCardResult.DataType> {
  override public func get(type: AuthMe.JPNResidentCardResult.DataType) -> Swift.String
  public enum DataType : Swift.String, Swift.CaseIterable {
    case name
    case gender
    case dateOfBirth
    case nationality
    case idNumber
    case address
    case age
    public init?(rawValue: Swift.String)
    public typealias AllCases = [AuthMe.JPNResidentCardResult.DataType]
    public typealias RawValue = Swift.String
    public static var allCases: [AuthMe.JPNResidentCardResult.DataType] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class JPNResidentCardNFCResult : AuthMe.OCRBaseResult<AuthMe.JPNResidentCardNFCResult.DataType> {
  override public func get(type: AuthMe.JPNResidentCardNFCResult.DataType) -> Swift.String
  public enum DataType : Swift.String, Swift.CaseIterable {
    case name
    case gender
    case dateOfBirth
    case nationality
    case address
    case visaStatus
    case documentNumber
    case restrictionEmployment
    case dateOfIssue
    case expiryDate
    case periodOfStay
    public init?(rawValue: Swift.String)
    public typealias AllCases = [AuthMe.JPNResidentCardNFCResult.DataType]
    public typealias RawValue = Swift.String
    public static var allCases: [AuthMe.JPNResidentCardNFCResult.DataType] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  convenience public init(data: [Swift.String : Swift.String], image: UIKit.UIImage?)
  public func setScanID(_ scanID: Swift.String)
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class USAIDCardResult : AuthMe.OCRBaseResult<AuthMe.USAIDCardResult.DataType> {
  override public func get(type: AuthMe.USAIDCardResult.DataType) -> Swift.String
  public enum DataType : Swift.String, Swift.CaseIterable {
    case address
    case country
    case dateOfBirth
    case dateOfIssue
    case gender
    case givenName
    case idNumber
    case middleName
    case name
    case nationality
    case region
    case surname
    public init?(rawValue: Swift.String)
    public typealias AllCases = [AuthMe.USAIDCardResult.DataType]
    public typealias RawValue = Swift.String
    public static var allCases: [AuthMe.USAIDCardResult.DataType] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class USADriverLicenseResult : AuthMe.OCRBaseResult<AuthMe.USADriverLicenseResult.DataType> {
  override public func get(type: AuthMe.USADriverLicenseResult.DataType) -> Swift.String
  public enum DataType : Swift.String, Swift.CaseIterable {
    case address
    case country
    case dateOfBirth
    case dateOfIssue
    case documentNumber
    case gender
    case givenName
    case middleName
    case name
    case nationality
    case region
    case surname
    public init?(rawValue: Swift.String)
    public typealias AllCases = [AuthMe.USADriverLicenseResult.DataType]
    public typealias RawValue = Swift.String
    public static var allCases: [AuthMe.USADriverLicenseResult.DataType] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class USAVisitorVISAResult : AuthMe.OCRBaseResult<AuthMe.USAVisitorVISAResult.DataType> {
  override public func get(type: AuthMe.USAVisitorVISAResult.DataType) -> Swift.String
  public enum DataType : Swift.String, Swift.CaseIterable {
    case address
    case country
    case dateOfBirth
    case expiryDate
    case givenName
    case middleName
    case name
    case surname
    public init?(rawValue: Swift.String)
    public typealias AllCases = [AuthMe.USAVisitorVISAResult.DataType]
    public typealias RawValue = Swift.String
    public static var allCases: [AuthMe.USAVisitorVISAResult.DataType] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class IDNIDCardResult : AuthMe.OCRBaseResult<AuthMe.IDNIDCardResult.DataType> {
  override public func get(type: AuthMe.IDNIDCardResult.DataType) -> Swift.String
  public enum DataType : Swift.String, Swift.CaseIterable {
    case address
    case dateOfBirth
    case dateOfIssue
    case gender
    case givenName
    case idNumber
    case middleName
    case name
    case placeOfBirth
    case surname
    public init?(rawValue: Swift.String)
    public typealias AllCases = [AuthMe.IDNIDCardResult.DataType]
    public typealias RawValue = Swift.String
    public static var allCases: [AuthMe.IDNIDCardResult.DataType] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class IDNDriverLicenseResult : AuthMe.OCRBaseResult<AuthMe.IDNDriverLicenseResult.DataType> {
  override public func get(type: AuthMe.IDNDriverLicenseResult.DataType) -> Swift.String
  public enum DataType : Swift.String, Swift.CaseIterable {
    case address
    case dateOfBirth
    case documentNumber
    case expiryDate
    case givenName
    case middleName
    case name
    case placeOfBirth
    case surname
    public init?(rawValue: Swift.String)
    public typealias AllCases = [AuthMe.IDNDriverLicenseResult.DataType]
    public typealias RawValue = Swift.String
    public static var allCases: [AuthMe.IDNDriverLicenseResult.DataType] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class INDIDCardResult : AuthMe.OCRBaseResult<AuthMe.INDIDCardResult.DataType> {
  override public func get(type: AuthMe.INDIDCardResult.DataType) -> Swift.String
  public enum DataType : Swift.String, Swift.CaseIterable {
    case address
    case dateOfBirth
    case dateOfIssue
    case gender
    case givenName
    case idNumber
    case middleName
    case name
    case placeOfBirth
    case surname
    public init?(rawValue: Swift.String)
    public typealias AllCases = [AuthMe.INDIDCardResult.DataType]
    public typealias RawValue = Swift.String
    public static var allCases: [AuthMe.INDIDCardResult.DataType] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class INDDriverLicenseResult : AuthMe.OCRBaseResult<AuthMe.INDDriverLicenseResult.DataType> {
  override public func get(type: AuthMe.INDDriverLicenseResult.DataType) -> Swift.String
  public enum DataType : Swift.String, Swift.CaseIterable {
    case address
    case dateOfBirth
    case documentNumber
    case expiryDate
    case givenName
    case middleName
    case name
    case placeOfBirth
    case surname
    public init?(rawValue: Swift.String)
    public typealias AllCases = [AuthMe.INDDriverLicenseResult.DataType]
    public typealias RawValue = Swift.String
    public static var allCases: [AuthMe.INDDriverLicenseResult.DataType] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class MYIDCardResult : AuthMe.OCRBaseResult<AuthMe.MYIDCardResult.DataType> {
  override public func get(type: AuthMe.MYIDCardResult.DataType) -> Swift.String
  public enum DataType : Swift.String, Swift.CaseIterable {
    case address
    case dateOfBirth
    case dateOfIssue
    case gender
    case givenName
    case idNumber
    case middleName
    case name
    case placeOfBirth
    case surname
    public init?(rawValue: Swift.String)
    public typealias AllCases = [AuthMe.MYIDCardResult.DataType]
    public typealias RawValue = Swift.String
    public static var allCases: [AuthMe.MYIDCardResult.DataType] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class MYDriverLicenseResult : AuthMe.OCRBaseResult<AuthMe.MYDriverLicenseResult.DataType> {
  override public func get(type: AuthMe.MYDriverLicenseResult.DataType) -> Swift.String
  public enum DataType : Swift.String, Swift.CaseIterable {
    case address
    case dateOfBirth
    case documentNumber
    case expiryDate
    case givenName
    case middleName
    case name
    case placeOfBirth
    case surname
    public init?(rawValue: Swift.String)
    public typealias AllCases = [AuthMe.MYDriverLicenseResult.DataType]
    public typealias RawValue = Swift.String
    public static var allCases: [AuthMe.MYDriverLicenseResult.DataType] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class HKIDCardResult : AuthMe.OCRBaseResult<AuthMe.HKIDCardResult.DataType> {
  override public func get(type: AuthMe.HKIDCardResult.DataType) -> Swift.String
  public enum DataType : Swift.String, Swift.CaseIterable {
    case address
    case dateOfBirth
    case dateOfIssue
    case gender
    case givenName
    case idNumber
    case middleName
    case name
    case placeOfBirth
    case surname
    public init?(rawValue: Swift.String)
    public typealias AllCases = [AuthMe.HKIDCardResult.DataType]
    public typealias RawValue = Swift.String
    public static var allCases: [AuthMe.HKIDCardResult.DataType] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class HKDriverLicenseResult : AuthMe.OCRBaseResult<AuthMe.HKDriverLicenseResult.DataType> {
  override public func get(type: AuthMe.HKDriverLicenseResult.DataType) -> Swift.String
  public enum DataType : Swift.String, Swift.CaseIterable {
    case address
    case dateOfBirth
    case documentNumber
    case expiryDate
    case givenName
    case middleName
    case name
    case placeOfBirth
    case surname
    public init?(rawValue: Swift.String)
    public typealias AllCases = [AuthMe.HKDriverLicenseResult.DataType]
    public typealias RawValue = Swift.String
    public static var allCases: [AuthMe.HKDriverLicenseResult.DataType] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class UKIDCardResult : AuthMe.OCRBaseResult<AuthMe.UKIDCardResult.DataType> {
  override public func get(type: AuthMe.UKIDCardResult.DataType) -> Swift.String
  public enum DataType : Swift.String, Swift.CaseIterable {
    case address
    case dateOfBirth
    case dateOfIssue
    case gender
    case givenName
    case idNumber
    case middleName
    case name
    case placeOfBirth
    case surname
    public init?(rawValue: Swift.String)
    public typealias AllCases = [AuthMe.UKIDCardResult.DataType]
    public typealias RawValue = Swift.String
    public static var allCases: [AuthMe.UKIDCardResult.DataType] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class UKDriverLicenseResult : AuthMe.OCRBaseResult<AuthMe.UKDriverLicenseResult.DataType> {
  override public func get(type: AuthMe.UKDriverLicenseResult.DataType) -> Swift.String
  public enum DataType : Swift.String, Swift.CaseIterable {
    case address
    case dateOfBirth
    case documentNumber
    case expiryDate
    case givenName
    case middleName
    case name
    case placeOfBirth
    case surname
    public init?(rawValue: Swift.String)
    public typealias AllCases = [AuthMe.UKDriverLicenseResult.DataType]
    public typealias RawValue = Swift.String
    public static var allCases: [AuthMe.UKDriverLicenseResult.DataType] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class EGIDCardResult : AuthMe.OCRBaseResult<AuthMe.EGIDCardResult.DataType> {
  override public func get(type: AuthMe.EGIDCardResult.DataType) -> Swift.String
  public enum DataType : Swift.String, Swift.CaseIterable {
    case address
    case dateOfBirth
    case dateOfIssue
    case gender
    case givenName
    case idNumber
    case middleName
    case name
    case placeOfBirth
    case surname
    public init?(rawValue: Swift.String)
    public typealias AllCases = [AuthMe.EGIDCardResult.DataType]
    public typealias RawValue = Swift.String
    public static var allCases: [AuthMe.EGIDCardResult.DataType] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class EGDriverLicenseResult : AuthMe.OCRBaseResult<AuthMe.EGDriverLicenseResult.DataType> {
  override public func get(type: AuthMe.EGDriverLicenseResult.DataType) -> Swift.String
  public enum DataType : Swift.String, Swift.CaseIterable {
    case address
    case dateOfBirth
    case documentNumber
    case expiryDate
    case givenName
    case middleName
    case name
    case placeOfBirth
    case surname
    public init?(rawValue: Swift.String)
    public typealias AllCases = [AuthMe.EGDriverLicenseResult.DataType]
    public typealias RawValue = Swift.String
    public static var allCases: [AuthMe.EGDriverLicenseResult.DataType] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class SAIDCardResult : AuthMe.OCRBaseResult<AuthMe.SAIDCardResult.DataType> {
  override public func get(type: AuthMe.SAIDCardResult.DataType) -> Swift.String
  public enum DataType : Swift.String, Swift.CaseIterable {
    case address
    case dateOfBirth
    case dateOfIssue
    case gender
    case givenName
    case idNumber
    case middleName
    case name
    case placeOfBirth
    case surname
    public init?(rawValue: Swift.String)
    public typealias AllCases = [AuthMe.SAIDCardResult.DataType]
    public typealias RawValue = Swift.String
    public static var allCases: [AuthMe.SAIDCardResult.DataType] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class SADriverLicenseResult : AuthMe.OCRBaseResult<AuthMe.SADriverLicenseResult.DataType> {
  override public func get(type: AuthMe.SADriverLicenseResult.DataType) -> Swift.String
  public enum DataType : Swift.String, Swift.CaseIterable {
    case address
    case dateOfBirth
    case documentNumber
    case expiryDate
    case givenName
    case middleName
    case name
    case placeOfBirth
    case surname
    public init?(rawValue: Swift.String)
    public typealias AllCases = [AuthMe.SADriverLicenseResult.DataType]
    public typealias RawValue = Swift.String
    public static var allCases: [AuthMe.SADriverLicenseResult.DataType] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class NLIDCardResult : AuthMe.OCRBaseResult<AuthMe.NLIDCardResult.DataType> {
  override public func get(type: AuthMe.NLIDCardResult.DataType) -> Swift.String
  public enum DataType : Swift.String, Swift.CaseIterable {
    case address
    case dateOfBirth
    case dateOfIssue
    case gender
    case givenName
    case idNumber
    case middleName
    case name
    case placeOfBirth
    case surname
    public init?(rawValue: Swift.String)
    public typealias AllCases = [AuthMe.NLIDCardResult.DataType]
    public typealias RawValue = Swift.String
    public static var allCases: [AuthMe.NLIDCardResult.DataType] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class NLDriverLicenseResult : AuthMe.OCRBaseResult<AuthMe.NLDriverLicenseResult.DataType> {
  override public func get(type: AuthMe.NLDriverLicenseResult.DataType) -> Swift.String
  public enum DataType : Swift.String, Swift.CaseIterable {
    case address
    case dateOfBirth
    case documentNumber
    case expiryDate
    case givenName
    case middleName
    case name
    case placeOfBirth
    case surname
    public init?(rawValue: Swift.String)
    public typealias AllCases = [AuthMe.NLDriverLicenseResult.DataType]
    public typealias RawValue = Swift.String
    public static var allCases: [AuthMe.NLDriverLicenseResult.DataType] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class SGIDCardResult : AuthMe.OCRBaseResult<AuthMe.SGIDCardResult.DataType> {
  override public func get(type: AuthMe.SGIDCardResult.DataType) -> Swift.String
  public enum DataType : Swift.String, Swift.CaseIterable {
    case address
    case dateOfBirth
    case dateOfIssue
    case gender
    case givenName
    case idNumber
    case middleName
    case name
    case placeOfBirth
    case surname
    public init?(rawValue: Swift.String)
    public typealias AllCases = [AuthMe.SGIDCardResult.DataType]
    public typealias RawValue = Swift.String
    public static var allCases: [AuthMe.SGIDCardResult.DataType] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class SGDriverLicenseResult : AuthMe.OCRBaseResult<AuthMe.SGDriverLicenseResult.DataType> {
  override public func get(type: AuthMe.SGDriverLicenseResult.DataType) -> Swift.String
  public enum DataType : Swift.String, Swift.CaseIterable {
    case address
    case dateOfBirth
    case documentNumber
    case expiryDate
    case givenName
    case middleName
    case name
    case placeOfBirth
    case surname
    public init?(rawValue: Swift.String)
    public typealias AllCases = [AuthMe.SGDriverLicenseResult.DataType]
    public typealias RawValue = Swift.String
    public static var allCases: [AuthMe.SGDriverLicenseResult.DataType] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  @objc deinit
}
public enum ScanType : Swift.String, Swift.Codable {
  case TWIDFraud
  case TWID
  case TWDriverLicense
  case TWHealth
  case Passport
  case NFCPassport
  case TWNResident
  case JPNID
  case JPNIDNFC
  case JPNDriverLicense
  case JPNDriverLicenseNFC
  case JPNResidentCard
  case JPNResidentCardNFC
  case USAID
  case USADriverLicense
  case USAVisitorVISA
  case IDNID
  case IDNDriverLicense
  case Liveness
  case PassportWithVIZ
  case INDID
  case INDDriverLicense
  case MYSID
  case MYSDriverLicense
  case HKGID
  case HKGIDFront
  case HKGDriverLicense
  case GBRID
  case GBRDriverLicense
  case EGYID
  case EGYDriverLicense
  case SAUID
  case SAUDriverLicense
  case NLDID
  case NLDDriverLicense
  case SGPID
  case SGPDriverLicense
  public func getOCRCardType() -> AuthMe.OCRCardType
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
@_inheritsConvenienceInitializers public class JPNNFCResidentCardFlow : AuthMe.BaseFlow {
  override public init(scanType: AuthMe.ScanType, needConfirm: Swift.Bool)
  @objc deinit
}
extension AuthMe.JPNNFCResidentCardFlow : AuthMe.ScanDocProtocol {
  public func checkModel(progressHandler: ((Swift.Double) -> Swift.Void)?, handler: ((Swift.Result<Swift.Void, AuthMe.OCRError>) -> Swift.Void)?)
  public func prepareScan(handler: @escaping (Swift.Result<(cardType: [AuthMe.ScanDocCardType], info: AuthMe.SessionInfo, expiredIn: Foundation.TimeInterval), AuthMe.OCRError>) -> Swift.Void)
  public func setPreviewSize(_ previewSize: CoreFoundation.CGSize)
  public func start(enableUploadFullFrame enable: Swift.Bool? = nil, handler: @escaping (Swift.Result<AuthMe.OCRInitScanDocResponse, AuthMe.OCRError>) -> Swift.Void)
  public func getCardMatchROI() -> AuthMe.CardMatchROI?
  public func onGetPreviewData(image: UIKit.UIImage, handler: @escaping (AuthMe.AuthmeOCRResult<AuthMe.OCRScanResult, ()?, AuthMe.OCRError>) -> Swift.Void)
  public func onGetIDCardFraudPreviewData(image: UIKit.UIImage, handler: @escaping (Swift.Result<AuthMe.OCRIDCardFraudStage, AuthMe.OCRError>) -> Swift.Void)
  public func restart() -> AuthMe.OCRError?
  public func recognize(handler: @escaping (Swift.Result<AuthMe.OCRScanResult, AuthMe.OCRError>) -> Swift.Void)
  public func recordImage(progressHandler: ((Swift.Double) -> Swift.Void)?, completion: @escaping (Swift.Result<Swift.Void, AuthMe.OCRError>) -> Swift.Void)
  public func getStatus() -> (scanDocs: [AuthMe.ScanDocCardType], processing: AuthMe.ScanDocCardType)
  public func stopScan() -> (any AuthMe.OCRResult)?
  public func abortScan(completion: @escaping (Swift.Result<Swift.Void, AuthMe.OCRError>) -> Swift.Void)
  public func addResult(_ result: [Swift.String : Swift.String])
  public func addImage(_ image: UIKit.UIImage?)
  public func onGetThicknessPreviewData(image: UIKit.UIImage, handler: @escaping (Swift.Result<(stage: AuthMe.OCRIDCardFraudStage, cropImage: UIKit.UIImage), AuthMe.OCRError>) -> Swift.Void)
  public func onGetThicknessManualData(image: UIKit.UIImage, handler: @escaping (Swift.Result<UIKit.UIImage, AuthMe.OCRError>) -> Swift.Void)
}
@_hasMissingDesignatedInitializers public class HKVIZClassifier {
  #if compiler(>=5.3) && $AsyncAwait
  public func containingTargetString(image: UIKit.UIImage?) async -> Swift.Bool
  #endif
  @objc deinit
}
public protocol FrameworkMode {
}
public enum JWTDecodeError : Foundation.LocalizedError, Swift.CustomDebugStringConvertible {
  case invalidBase64URL(Swift.String)
  case invalidJSON(Swift.String)
  case invalidPartCount(Swift.String, Swift.Int)
  public var localizedDescription: Swift.String {
    get
  }
  public var errorDescription: Swift.String? {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
public class OCRScanDocFactory {
  public init()
  public func prepare(scanType: AuthMe.ScanType, eventName: Swift.String, needConfirm: Swift.Bool, isNFCOffline: Swift.Bool) -> any AuthMe.ScanDocProtocol
  @objc deinit
}
public protocol LivenessFlowProtocol {
  func setDelegate(_ delegate: any AuthMe.LivenessFlowDelegate)
  func checkModel(progressHandler: ((Swift.Double) -> Swift.Void)?, handler: ((Swift.Result<Swift.Void, AuthMe.FlowError>) -> Swift.Void)?)
  func setPreviewSize(previewSize: CoreFoundation.CGSize)
  func start(encrypt: Swift.Bool)
  func roiRect(in previewSize: CoreFoundation.CGSize) -> CoreFoundation.CGRect
  func recognize(image: UIKit.UIImage)
  func recognize(normal normalImage: UIKit.UIImage, depthImage: UIKit.UIImage)
  func getResult(completion: @escaping ((Swift.Bool) -> Swift.Void))
  func isExpired() -> Swift.Bool
  func cancelExpired()
  func enableUploadFullFrame()
}
extension AuthMe.LivenessFlowProtocol {
  public func recognize(normal normalImage: UIKit.UIImage, depthImage: UIKit.UIImage)
}
public class LivenessFactory {
  public init()
  public func prepare(with action: AuthMe.Action = .register(waitResult: true)) -> any AuthMe.LivenessFlowProtocol
  public func preparePlayground() -> any AuthMe.LivenessFlowProtocol
  public func prepareRecordPlayground() -> any AuthMe.LivenessFlowProtocol
  @objc deinit
}
public enum Action {
  case register(waitResult: Swift.Bool)
  case verify(_: Swift.Bool)
}
public enum FlowError : Swift.Error {
  case checkModel
  case start
  case recognize
  case service(AuthMe.FlowError.Endpoint, code: Swift.String?)
  case expiredIn
  public enum Endpoint {
    case `init`
    case detect
    case verify
    public static func == (a: AuthMe.FlowError.Endpoint, b: AuthMe.FlowError.Endpoint) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
@_hasMissingDesignatedInitializers public class OnlineMode : AuthMe.FrameworkMode {
  @objc deinit
}
@objc @_inheritsConvenienceInitializers public class AuthmeCoreOnlineBuilder : ObjectiveC.NSObject {
  public func setAccessToken(_ accessToken: Swift.String) -> AuthMe.AuthmeCoreOnlineBuilder
  public func setConfig(_ config: AuthMe.AuthMeConfig) -> AuthMe.AuthmeCoreOnlineBuilder
  public func build() -> Swift.Result<Swift.Void, any Swift.Error>
  @objc override dynamic public init()
  @objc deinit
}
public protocol LivenessPlaygroundRecordFlowDelegate : AuthMe.LivenessFlowDelegate {
  func livenessDidNotifyMessage(message: Swift.String)
  func livenessDidUpdateReconize(result: Swift.Bool)
  func livenessDidFailureWith(error: AuthMe.FlowError, retryHandler: @escaping (() -> Swift.Void))
  func livenessDidRecognize(image: UIKit.UIImage)
  func livenessDidFaceScale(direction: AuthMe.LivenessFlow.FaceScaleDirection.Direction)
  func livenessDidProcessed(jsonString: Swift.String)
}
public class JPIDNFCCardFlow {
  public init(scanType: AuthMe.ScanType, needConfirm: Swift.Bool)
  @objc deinit
}
extension AuthMe.JPIDNFCCardFlow : AuthMe.ScanDocProtocol {
  public func checkModel(progressHandler: ((Swift.Double) -> Swift.Void)?, handler: ((Swift.Result<Swift.Void, AuthMe.OCRError>) -> Swift.Void)?)
  public func prepareScan(handler: @escaping (Swift.Result<(cardType: [AuthMe.ScanDocCardType], info: AuthMe.SessionInfo, expiredIn: Foundation.TimeInterval), AuthMe.OCRError>) -> Swift.Void)
  public func setPreviewSize(_ previewSize: CoreFoundation.CGSize)
  public func start(enableUploadFullFrame enable: Swift.Bool? = nil, handler: @escaping (Swift.Result<AuthMe.OCRInitScanDocResponse, AuthMe.OCRError>) -> Swift.Void)
  public func getCardMatchROI() -> AuthMe.CardMatchROI?
  public func onGetPreviewData(image: UIKit.UIImage, handler: @escaping (AuthMe.AuthmeOCRResult<AuthMe.OCRScanResult, ()?, AuthMe.OCRError>) -> Swift.Void)
  public func onGetIDCardFraudPreviewData(image: UIKit.UIImage, handler: @escaping (Swift.Result<AuthMe.OCRIDCardFraudStage, AuthMe.OCRError>) -> Swift.Void)
  public func restart() -> AuthMe.OCRError?
  public func recognize(handler: @escaping (Swift.Result<AuthMe.OCRScanResult, AuthMe.OCRError>) -> Swift.Void)
  public func recordImage(progressHandler: ((Swift.Double) -> Swift.Void)?, completion: @escaping (Swift.Result<Swift.Void, AuthMe.OCRError>) -> Swift.Void)
  public func getStatus() -> (scanDocs: [AuthMe.ScanDocCardType], processing: AuthMe.ScanDocCardType)
  public func stopScan() -> (any AuthMe.OCRResult)?
  public func abortScan(completion: @escaping (Swift.Result<Swift.Void, AuthMe.OCRError>) -> Swift.Void)
  public func addResult(_ result: [Swift.String : Swift.String])
  public func addImage(_ image: UIKit.UIImage?)
  public func onGetThicknessPreviewData(image: UIKit.UIImage, handler: @escaping (Swift.Result<(stage: AuthMe.OCRIDCardFraudStage, cropImage: UIKit.UIImage), AuthMe.OCRError>) -> Swift.Void)
  public func onGetThicknessManualData(image: UIKit.UIImage, handler: @escaping (Swift.Result<UIKit.UIImage, AuthMe.OCRError>) -> Swift.Void)
}
public class EncryptHelper {
  public init()
  public func encryptWithRSA(plaintext: Swift.String) -> Swift.String?
  public func decryptWithRSA(encryptedText: Swift.String, publicKey: Swift.String) -> Swift.String?
  @objc deinit
}
public struct OCRScanViewContentViewRequest {
  public struct OCRScanViewContentViewResponse : Swift.Decodable {
    public init(from decoder: any Swift.Decoder) throws
  }
}
extension UIKit.UIDevice {
  @_Concurrency.MainActor(unsafe) public static let modelName: Swift.String
}
public class BaseFlow {
  public init(scanType: AuthMe.ScanType, needConfirm: Swift.Bool)
  @objc deinit
}
@_inheritsConvenienceInitializers public class JPNNFCDriverLicenseFlow : AuthMe.BaseFlow {
  override public init(scanType: AuthMe.ScanType, needConfirm: Swift.Bool)
  @objc deinit
}
extension AuthMe.JPNNFCDriverLicenseFlow : AuthMe.ScanDocProtocol {
  public func checkModel(progressHandler: ((Swift.Double) -> Swift.Void)?, handler: ((Swift.Result<Swift.Void, AuthMe.OCRError>) -> Swift.Void)?)
  public func prepareScan(handler: @escaping (Swift.Result<(cardType: [AuthMe.ScanDocCardType], info: AuthMe.SessionInfo, expiredIn: Foundation.TimeInterval), AuthMe.OCRError>) -> Swift.Void)
  public func setPreviewSize(_ previewSize: CoreFoundation.CGSize)
  public func start(enableUploadFullFrame enable: Swift.Bool? = nil, handler: @escaping (Swift.Result<AuthMe.OCRInitScanDocResponse, AuthMe.OCRError>) -> Swift.Void)
  public func getCardMatchROI() -> AuthMe.CardMatchROI?
  public func onGetPreviewData(image: UIKit.UIImage, handler: @escaping (AuthMe.AuthmeOCRResult<AuthMe.OCRScanResult, ()?, AuthMe.OCRError>) -> Swift.Void)
  public func onGetIDCardFraudPreviewData(image: UIKit.UIImage, handler: @escaping (Swift.Result<AuthMe.OCRIDCardFraudStage, AuthMe.OCRError>) -> Swift.Void)
  public func restart() -> AuthMe.OCRError?
  public func recognize(handler: @escaping (Swift.Result<AuthMe.OCRScanResult, AuthMe.OCRError>) -> Swift.Void)
  public func recordImage(progressHandler: ((Swift.Double) -> Swift.Void)?, completion: @escaping (Swift.Result<Swift.Void, AuthMe.OCRError>) -> Swift.Void)
  public func getStatus() -> (scanDocs: [AuthMe.ScanDocCardType], processing: AuthMe.ScanDocCardType)
  public func stopScan() -> (any AuthMe.OCRResult)?
  public func abortScan(completion: @escaping (Swift.Result<Swift.Void, AuthMe.OCRError>) -> Swift.Void)
  public func addResult(_ result: [Swift.String : Swift.String])
  public func addImage(_ image: UIKit.UIImage?)
  public func onGetThicknessPreviewData(image: UIKit.UIImage, handler: @escaping (Swift.Result<(stage: AuthMe.OCRIDCardFraudStage, cropImage: UIKit.UIImage), AuthMe.OCRError>) -> Swift.Void)
  public func onGetThicknessManualData(image: UIKit.UIImage, handler: @escaping (Swift.Result<UIKit.UIImage, AuthMe.OCRError>) -> Swift.Void)
}
public protocol LivenessPlaygroundFlowDelegate : AuthMe.LivenessFlowDelegate {
  func livenessDidNotifyMessage(status: AuthMe.LivenessDetectStatus)
  func livenessDidUpdateReconize(result: Swift.Bool)
  func livenessDidFailureWith(error: AuthMe.FlowError, retryHandler: @escaping (() -> Swift.Void))
  func livenessDidRecognize(image: UIKit.UIImage)
  func livenessQueueDidUpload(currentCount: Swift.Int)
}
public class LivenessPlaygroundFlow {
  weak public var delegate: (any AuthMe.LivenessPlaygroundFlowDelegate)?
  public init()
  @objc deinit
}
extension AuthMe.LivenessPlaygroundFlow : AuthMe.LivenessFlowProtocol {
  public func setDelegate(_ delegate: any AuthMe.LivenessFlowDelegate)
  public func checkModel(progressHandler: ((Swift.Double) -> Swift.Void)? = nil, handler: ((Swift.Result<Swift.Void, AuthMe.FlowError>) -> Swift.Void)?)
  public func setPreviewSize(previewSize: CoreFoundation.CGSize)
  public func start(encrypt: Swift.Bool)
  public func recognize(image: UIKit.UIImage)
  public func roiRect(in previewSize: CoreFoundation.CGSize) -> CoreFoundation.CGRect
  public func getResult(completion: @escaping ((Swift.Bool) -> Swift.Void))
  public func isExpired() -> Swift.Bool
  public func cancelExpired()
  public func enableUploadFullFrame()
}
final public class URLEncodedFormEncoder {
  public enum ArrayEncoding {
    case brackets
    case noBrackets
    case indexInBrackets
    public static func == (a: AuthMe.URLEncodedFormEncoder.ArrayEncoding, b: AuthMe.URLEncodedFormEncoder.ArrayEncoding) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum BoolEncoding {
    case numeric
    case literal
    public static func == (a: AuthMe.URLEncodedFormEncoder.BoolEncoding, b: AuthMe.URLEncodedFormEncoder.BoolEncoding) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum DataEncoding {
    case deferredToData
    case base64
    case custom((Foundation.Data) throws -> Swift.String)
  }
  public enum DateEncoding {
    case deferredToDate
    case secondsSince1970
    case millisecondsSince1970
    case iso8601
    case formatted(Foundation.DateFormatter)
    case custom((Foundation.Date) throws -> Swift.String)
  }
  public enum KeyEncoding {
    case useDefaultKeys
    case convertToSnakeCase
    case convertToKebabCase
    case capitalized
    case uppercased
    case lowercased
    case custom((Swift.String) -> Swift.String)
  }
  public enum SpaceEncoding {
    case percentEscaped
    case plusReplaced
    public static func == (a: AuthMe.URLEncodedFormEncoder.SpaceEncoding, b: AuthMe.URLEncodedFormEncoder.SpaceEncoding) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Error : Swift.Error {
    case invalidRootObject(Swift.String)
  }
  final public let alphabetizeKeyValuePairs: Swift.Bool
  final public let arrayEncoding: AuthMe.URLEncodedFormEncoder.ArrayEncoding
  final public let boolEncoding: AuthMe.URLEncodedFormEncoder.BoolEncoding
  final public let dataEncoding: AuthMe.URLEncodedFormEncoder.DataEncoding
  final public let dateEncoding: AuthMe.URLEncodedFormEncoder.DateEncoding
  final public let keyEncoding: AuthMe.URLEncodedFormEncoder.KeyEncoding
  final public let spaceEncoding: AuthMe.URLEncodedFormEncoder.SpaceEncoding
  final public var allowedCharacters: Foundation.CharacterSet
  public init(alphabetizeKeyValuePairs: Swift.Bool = true, arrayEncoding: AuthMe.URLEncodedFormEncoder.ArrayEncoding = .brackets, boolEncoding: AuthMe.URLEncodedFormEncoder.BoolEncoding = .numeric, dataEncoding: AuthMe.URLEncodedFormEncoder.DataEncoding = .base64, dateEncoding: AuthMe.URLEncodedFormEncoder.DateEncoding = .deferredToDate, keyEncoding: AuthMe.URLEncodedFormEncoder.KeyEncoding = .useDefaultKeys, spaceEncoding: AuthMe.URLEncodedFormEncoder.SpaceEncoding = .percentEscaped, allowedCharacters: Foundation.CharacterSet = .afURLQueryAllowed)
  final public func encode(_ value: any Swift.Encodable) throws -> Swift.String
  final public func encode(_ value: any Swift.Encodable) throws -> Foundation.Data
  @objc deinit
}
extension Foundation.CharacterSet {
  public static let afURLQueryAllowed: Foundation.CharacterSet
}
public protocol JWT {
  var header: [Swift.String : Any] { get }
  var body: [Swift.String : Any] { get }
  var signature: Swift.String? { get }
  var string: Swift.String { get }
  var expiresAt: Foundation.Date? { get }
  var issuer: Swift.String? { get }
  var subject: Swift.String? { get }
  var audience: [Swift.String]? { get }
  var issuedAt: Foundation.Date? { get }
  var notBefore: Foundation.Date? { get }
  var identifier: Swift.String? { get }
  var expired: Swift.Bool { get }
}
extension AuthMe.JWT {
  public func claim(name: Swift.String) -> AuthMe.Claim
  public subscript(claim: Swift.String) -> AuthMe.Claim {
    get
  }
}
public protocol ScanDocProtocol {
  func checkModel(progressHandler: ((Swift.Double) -> Swift.Void)?, handler: ((Swift.Result<Swift.Void, AuthMe.OCRError>) -> Swift.Void)?)
  func prepareScan(handler: @escaping (Swift.Result<(cardType: [AuthMe.ScanDocCardType], info: AuthMe.SessionInfo, expiredIn: Foundation.TimeInterval), AuthMe.OCRError>) -> Swift.Void)
  func setPreviewSize(_ previewSize: CoreFoundation.CGSize)
  func start(enableUploadFullFrame: Swift.Bool?, handler: @escaping (Swift.Result<AuthMe.OCRInitScanDocResponse, AuthMe.OCRError>) -> Swift.Void)
  func onGetPreviewData(image: UIKit.UIImage, handler: @escaping (AuthMe.AuthmeOCRResult<AuthMe.OCRScanResult, ()?, AuthMe.OCRError>) -> Swift.Void)
  func getCardMatchROI() -> AuthMe.CardMatchROI?
  func onGetIDCardFraudPreviewData(image: UIKit.UIImage, handler: @escaping (Swift.Result<AuthMe.OCRIDCardFraudStage, AuthMe.OCRError>) -> Swift.Void)
  func onGetThicknessPreviewData(image: UIKit.UIImage, handler: @escaping (Swift.Result<(stage: AuthMe.OCRIDCardFraudStage, cropImage: UIKit.UIImage), AuthMe.OCRError>) -> Swift.Void)
  func onGetThicknessManualData(image: UIKit.UIImage, handler: @escaping (Swift.Result<UIKit.UIImage, AuthMe.OCRError>) -> Swift.Void)
  func restart() -> AuthMe.OCRError?
  func recognize(handler: @escaping (Swift.Result<AuthMe.OCRScanResult, AuthMe.OCRError>) -> Swift.Void)
  func recordImage(progressHandler: ((Swift.Double) -> Swift.Void)?, completion: @escaping (Swift.Result<Swift.Void, AuthMe.OCRError>) -> Swift.Void)
  func recordImageWithBase64(_ image: UIKit.UIImage, progressHandler: ((Swift.Double) -> Swift.Void)?, completion: @escaping (Swift.Result<Swift.Void, AuthMe.OCRError>) -> Swift.Void)
  func getStatus() -> (scanDocs: [AuthMe.ScanDocCardType], processing: AuthMe.ScanDocCardType)
  func stopScan() -> (any AuthMe.OCRResult)?
  func abortScan(completion: @escaping (Swift.Result<Swift.Void, AuthMe.OCRError>) -> Swift.Void)
  func addResult(_ result: [Swift.String : Swift.String])
  func addImage(_ image: UIKit.UIImage?)
  func startWithoutEngine(cardType: AuthMe.OCRType, handler: @escaping (Swift.Result<AuthMe.OCRInitScanDocResponse, AuthMe.OCRError>) -> Swift.Void)
}
extension AuthMe.ScanDocProtocol {
  public func recordImageWithBase64(_ image: UIKit.UIImage, progressHandler: ((Swift.Double) -> Swift.Void)?, completion: @escaping (Swift.Result<Swift.Void, AuthMe.OCRError>) -> Swift.Void)
  public func addResult(_ result: [Swift.String : Swift.String])
  public func addImage(_ image: UIKit.UIImage?)
  public func startWithoutEngine(cardType: AuthMe.OCRType, handler: @escaping (Swift.Result<AuthMe.OCRInitScanDocResponse, AuthMe.OCRError>) -> Swift.Void)
}
public struct OCRScanResult {
  public let originalImage: UIKit.UIImage
  public let cropImage: UIKit.UIImage
  public let context: [Swift.String : Swift.String]
}
public enum OCRIDCardFraudStage {
  case frontal
  case left
  case right
  case up
  case down
  case ocrscan
  public static func == (a: AuthMe.OCRIDCardFraudStage, b: AuthMe.OCRIDCardFraudStage) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum ScanDocStatus {
  case idle
  case processing
  case done
  public static func == (a: AuthMe.ScanDocStatus, b: AuthMe.ScanDocStatus) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum ScanDocCardType : Swift.String, Swift.Codable {
  case TWN_IDCard_Fraud_Front
  case TWN_IDCard_Front
  case TWN_IDCard_Back
  case TWN_DriverLicense_Front
  case TWN_DriverLicense_Back
  case TWN_HealthCard_Front
  case Passport
  case NFCPassport
  case TWN_ResidentCard_Front
  case TWN_ResidentCard_Back
  case JPN_IDCARD_Front
  case JPN_IDCARD_Back
  case JPN_IDCard_NFC
  case JPN_IDCARD_Thickness
  case JPN_DriverLicense_Front
  case JPN_DriverLicense_Back
  case JPN_DriverLicense_NFC
  case JPN_DriverLicense_Thickness
  case JPN_ResidentCard_Front
  case JPN_ResidentCard_Back
  case JPN_ResidentCard_Thickness
  case JPN_ResidentCard_NFC
  case USA_IDCARD_Front
  case USA_DriverLicense_Front
  case USA_VisitorVISA_FRONT
  case IDN_IDCARD_Front
  case IDN_IDCARD_Back
  case IDN_DriverLicense_Front
  case Liveness
  case PassportWithVIZ
  case IND_IDCard_Front
  case IND_IDCard_Back
  case IND_DriverLicense_Front
  case MYS_IDCard_Front
  case MYS_IDCard_Back
  case MYS_DriverLicense_Front
  case HKG_IDCard_Front
  case HKG_IDCard_Back
  case HKG_DriverLicense_Front
  case GBR_IDCard_Front
  case GBR_DriverLicense_Front
  case GBR_DriverLicense_Back
  case EGY_IDCard_Front
  case EGY_IDCard_Back
  case EGY_DriverLicense_Front
  case SAU_IDCard_Front
  case SAU_IDCard_Back
  case SAU_DriverLicense_Front
  case NLD_IDCard_Front
  case NLD_DriverLicense_Front
  case SGP_IDCard_Front
  case SGP_IDCard_Back
  case SGP_DriverLicense_Front
  case UnknownCard
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
extension AuthMe.ScanDocCardType {
  public func getMaskRect(frame: CoreFoundation.CGRect) -> CoreFoundation.CGRect
}
public struct CardMatchROI {
  public let leftUp: CoreFoundation.CGPoint
  public let leftDown: CoreFoundation.CGPoint
  public let rightUp: CoreFoundation.CGPoint
  public let rightDown: CoreFoundation.CGPoint
}
public typealias onlinePassport = AuthMe.OnlineMode.Passport
extension AuthMe.OnlineMode {
  public enum Passport : Swift.String, AuthMe.EKYCType {
    case Passport
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
}
public typealias offlinePassport = AuthMe.OfflineMode.Passport
extension AuthMe.OfflineMode {
  public enum Passport : Swift.String, AuthMe.EKYCType {
    case Passport
    case PassportWithVIZ
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
}
@_hasMissingDesignatedInitializers public class CVMath {
  public static func transformedLeftPoint(w: Swift.Float, h: Swift.Float, degree: Swift.Float, x: inout Swift.Float, y: inout Swift.Float)
  public static func transformedTopPoint(w: Swift.Float, h: Swift.Float, degree: Swift.Float, x: inout Swift.Float, y: inout Swift.Float)
  @objc deinit
}
public class EventHelper {
  public init()
  @objc deinit
  public func stop()
  public func saveLogWith(sessionInfo: AuthMe.SessionInfo? = nil, info: AuthMe.EventInfo, preEvent: AuthMe.EventInfo? = nil)
  public func saveLogWithDuration(_ duration: Swift.String = "0", sessionInfo: AuthMe.SessionInfo? = nil, info: AuthMe.EventInfo)
  public func saveLog(info: AuthMe.EventInfo, sessionId: Swift.String = "", tenantId: Swift.String = "", customerId: Swift.String = "", preEvent: AuthMe.EventInfo? = nil)
}
public struct EventInfo {
  public init(eventID: Foundation.UUID = UUID(), log: Swift.String, language: Swift.String = "", description: Swift.String = "", extraInfo: Swift.String = "")
}
extension AuthMe.LogFAS.LogStage : Swift.Equatable {}
extension AuthMe.LogFAS.LogStage : Swift.Hashable {}
extension AuthMe.LogFAS.LogFASResult : Swift.Equatable {}
extension AuthMe.LogFAS.LogFASResult : Swift.Hashable {}
extension AuthMe.LogUpload.Event : Swift.Equatable {}
extension AuthMe.LogUpload.Event : Swift.Hashable {}
extension AuthMe.LivenessDetectStatus : Swift.Equatable {}
extension AuthMe.LivenessDetectStatus : Swift.Hashable {}
extension AuthMe.LivenessFlow.FaceScaleDirection.Direction : Swift.Equatable {}
extension AuthMe.LivenessFlow.FaceScaleDirection.Direction : Swift.Hashable {}
extension AuthMe.LogAntiFraud : Swift.Equatable {}
extension AuthMe.LogAntiFraud : Swift.Hashable {}
extension AuthMe.LogAntiFraud : Swift.RawRepresentable {}
extension AuthMe.OCRCardType : Swift.Equatable {}
extension AuthMe.OCRCardType : Swift.Hashable {}
extension AuthMe.OCRCardType : Swift.RawRepresentable {}
extension AuthMe.OCRType : Swift.Equatable {}
extension AuthMe.OCRType : Swift.Hashable {}
extension AuthMe.OCRType : Swift.RawRepresentable {}
extension AuthMe.OCRError : Swift.Equatable {}
extension AuthMe.OCRError : Swift.Hashable {}
extension AuthMe.OCRError : Swift.RawRepresentable {}
extension AuthMe.OCRNotifyMessage : Swift.Equatable {}
extension AuthMe.OCRNotifyMessage : Swift.Hashable {}
extension AuthMe.OCRNotifyMessage : Swift.RawRepresentable {}
extension AuthMe.DebugMessageChannel : Swift.Equatable {}
extension AuthMe.DebugMessageChannel : Swift.Hashable {}
extension AuthMe.OCRInitScanDocResponse.OCRScanView.OCRScanViewBorder.OCRScanViewBorderType : Swift.Equatable {}
extension AuthMe.OCRInitScanDocResponse.OCRScanView.OCRScanViewBorder.OCRScanViewBorderType : Swift.Hashable {}
extension AuthMe.OCRInitScanDocResponse.OCRScanView.OCRScanViewBorder.OCRScanViewBorderType : Swift.RawRepresentable {}
extension AuthMe.OCRInitScanDocResponse.OCRScanView.OCRScanViewContent.OCRScanViewContentType : Swift.Equatable {}
extension AuthMe.OCRInitScanDocResponse.OCRScanView.OCRScanViewContent.OCRScanViewContentType : Swift.Hashable {}
extension AuthMe.OCRInitScanDocResponse.OCRScanView.OCRScanViewContent.OCRScanViewContentType : Swift.RawRepresentable {}
extension AuthMe.MRZResult.DataType : Swift.Equatable {}
extension AuthMe.MRZResult.DataType : Swift.Hashable {}
extension AuthMe.MRZResult.DataType : Swift.RawRepresentable {}
extension AuthMe.TWNResidentResult.DataType : Swift.Equatable {}
extension AuthMe.TWNResidentResult.DataType : Swift.Hashable {}
extension AuthMe.TWNResidentResult.DataType : Swift.RawRepresentable {}
extension AuthMe.TWIDResult.DataType : Swift.Equatable {}
extension AuthMe.TWIDResult.DataType : Swift.Hashable {}
extension AuthMe.TWIDResult.DataType : Swift.RawRepresentable {}
extension AuthMe.TWLicenseResult.DataType : Swift.Equatable {}
extension AuthMe.TWLicenseResult.DataType : Swift.Hashable {}
extension AuthMe.TWLicenseResult.DataType : Swift.RawRepresentable {}
extension AuthMe.TWHealthResult.DataType : Swift.Equatable {}
extension AuthMe.TWHealthResult.DataType : Swift.Hashable {}
extension AuthMe.TWHealthResult.DataType : Swift.RawRepresentable {}
extension AuthMe.JPNIDCardResult.DataType : Swift.Equatable {}
extension AuthMe.JPNIDCardResult.DataType : Swift.Hashable {}
extension AuthMe.JPNIDCardResult.DataType : Swift.RawRepresentable {}
extension AuthMe.JPNIDCardNFCResult.DataType : Swift.Equatable {}
extension AuthMe.JPNIDCardNFCResult.DataType : Swift.Hashable {}
extension AuthMe.JPNIDCardNFCResult.DataType : Swift.RawRepresentable {}
extension AuthMe.JPNDriverLicenseResult.DataType : Swift.Equatable {}
extension AuthMe.JPNDriverLicenseResult.DataType : Swift.Hashable {}
extension AuthMe.JPNDriverLicenseResult.DataType : Swift.RawRepresentable {}
extension AuthMe.JPNDriverLicenseNFCResult.DataType : Swift.Equatable {}
extension AuthMe.JPNDriverLicenseNFCResult.DataType : Swift.Hashable {}
extension AuthMe.JPNDriverLicenseNFCResult.DataType : Swift.RawRepresentable {}
extension AuthMe.JPNResidentCardResult.DataType : Swift.Equatable {}
extension AuthMe.JPNResidentCardResult.DataType : Swift.Hashable {}
extension AuthMe.JPNResidentCardResult.DataType : Swift.RawRepresentable {}
extension AuthMe.JPNResidentCardNFCResult.DataType : Swift.Equatable {}
extension AuthMe.JPNResidentCardNFCResult.DataType : Swift.Hashable {}
extension AuthMe.JPNResidentCardNFCResult.DataType : Swift.RawRepresentable {}
extension AuthMe.USAIDCardResult.DataType : Swift.Equatable {}
extension AuthMe.USAIDCardResult.DataType : Swift.Hashable {}
extension AuthMe.USAIDCardResult.DataType : Swift.RawRepresentable {}
extension AuthMe.USADriverLicenseResult.DataType : Swift.Equatable {}
extension AuthMe.USADriverLicenseResult.DataType : Swift.Hashable {}
extension AuthMe.USADriverLicenseResult.DataType : Swift.RawRepresentable {}
extension AuthMe.USAVisitorVISAResult.DataType : Swift.Equatable {}
extension AuthMe.USAVisitorVISAResult.DataType : Swift.Hashable {}
extension AuthMe.USAVisitorVISAResult.DataType : Swift.RawRepresentable {}
extension AuthMe.IDNIDCardResult.DataType : Swift.Equatable {}
extension AuthMe.IDNIDCardResult.DataType : Swift.Hashable {}
extension AuthMe.IDNIDCardResult.DataType : Swift.RawRepresentable {}
extension AuthMe.IDNDriverLicenseResult.DataType : Swift.Equatable {}
extension AuthMe.IDNDriverLicenseResult.DataType : Swift.Hashable {}
extension AuthMe.IDNDriverLicenseResult.DataType : Swift.RawRepresentable {}
extension AuthMe.INDIDCardResult.DataType : Swift.Equatable {}
extension AuthMe.INDIDCardResult.DataType : Swift.Hashable {}
extension AuthMe.INDIDCardResult.DataType : Swift.RawRepresentable {}
extension AuthMe.INDDriverLicenseResult.DataType : Swift.Equatable {}
extension AuthMe.INDDriverLicenseResult.DataType : Swift.Hashable {}
extension AuthMe.INDDriverLicenseResult.DataType : Swift.RawRepresentable {}
extension AuthMe.MYIDCardResult.DataType : Swift.Equatable {}
extension AuthMe.MYIDCardResult.DataType : Swift.Hashable {}
extension AuthMe.MYIDCardResult.DataType : Swift.RawRepresentable {}
extension AuthMe.MYDriverLicenseResult.DataType : Swift.Equatable {}
extension AuthMe.MYDriverLicenseResult.DataType : Swift.Hashable {}
extension AuthMe.MYDriverLicenseResult.DataType : Swift.RawRepresentable {}
extension AuthMe.HKIDCardResult.DataType : Swift.Equatable {}
extension AuthMe.HKIDCardResult.DataType : Swift.Hashable {}
extension AuthMe.HKIDCardResult.DataType : Swift.RawRepresentable {}
extension AuthMe.HKDriverLicenseResult.DataType : Swift.Equatable {}
extension AuthMe.HKDriverLicenseResult.DataType : Swift.Hashable {}
extension AuthMe.HKDriverLicenseResult.DataType : Swift.RawRepresentable {}
extension AuthMe.UKIDCardResult.DataType : Swift.Equatable {}
extension AuthMe.UKIDCardResult.DataType : Swift.Hashable {}
extension AuthMe.UKIDCardResult.DataType : Swift.RawRepresentable {}
extension AuthMe.UKDriverLicenseResult.DataType : Swift.Equatable {}
extension AuthMe.UKDriverLicenseResult.DataType : Swift.Hashable {}
extension AuthMe.UKDriverLicenseResult.DataType : Swift.RawRepresentable {}
extension AuthMe.EGIDCardResult.DataType : Swift.Equatable {}
extension AuthMe.EGIDCardResult.DataType : Swift.Hashable {}
extension AuthMe.EGIDCardResult.DataType : Swift.RawRepresentable {}
extension AuthMe.EGDriverLicenseResult.DataType : Swift.Equatable {}
extension AuthMe.EGDriverLicenseResult.DataType : Swift.Hashable {}
extension AuthMe.EGDriverLicenseResult.DataType : Swift.RawRepresentable {}
extension AuthMe.SAIDCardResult.DataType : Swift.Equatable {}
extension AuthMe.SAIDCardResult.DataType : Swift.Hashable {}
extension AuthMe.SAIDCardResult.DataType : Swift.RawRepresentable {}
extension AuthMe.SADriverLicenseResult.DataType : Swift.Equatable {}
extension AuthMe.SADriverLicenseResult.DataType : Swift.Hashable {}
extension AuthMe.SADriverLicenseResult.DataType : Swift.RawRepresentable {}
extension AuthMe.NLIDCardResult.DataType : Swift.Equatable {}
extension AuthMe.NLIDCardResult.DataType : Swift.Hashable {}
extension AuthMe.NLIDCardResult.DataType : Swift.RawRepresentable {}
extension AuthMe.NLDriverLicenseResult.DataType : Swift.Equatable {}
extension AuthMe.NLDriverLicenseResult.DataType : Swift.Hashable {}
extension AuthMe.NLDriverLicenseResult.DataType : Swift.RawRepresentable {}
extension AuthMe.SGIDCardResult.DataType : Swift.Equatable {}
extension AuthMe.SGIDCardResult.DataType : Swift.Hashable {}
extension AuthMe.SGIDCardResult.DataType : Swift.RawRepresentable {}
extension AuthMe.SGDriverLicenseResult.DataType : Swift.Equatable {}
extension AuthMe.SGDriverLicenseResult.DataType : Swift.Hashable {}
extension AuthMe.SGDriverLicenseResult.DataType : Swift.RawRepresentable {}
extension AuthMe.ScanType : Swift.Equatable {}
extension AuthMe.ScanType : Swift.Hashable {}
extension AuthMe.ScanType : Swift.RawRepresentable {}
extension AuthMe.FlowError.Endpoint : Swift.Equatable {}
extension AuthMe.FlowError.Endpoint : Swift.Hashable {}
extension AuthMe.URLEncodedFormEncoder.ArrayEncoding : Swift.Equatable {}
extension AuthMe.URLEncodedFormEncoder.ArrayEncoding : Swift.Hashable {}
extension AuthMe.URLEncodedFormEncoder.BoolEncoding : Swift.Equatable {}
extension AuthMe.URLEncodedFormEncoder.BoolEncoding : Swift.Hashable {}
extension AuthMe.URLEncodedFormEncoder.SpaceEncoding : Swift.Equatable {}
extension AuthMe.URLEncodedFormEncoder.SpaceEncoding : Swift.Hashable {}
extension AuthMe.OCRIDCardFraudStage : Swift.Equatable {}
extension AuthMe.OCRIDCardFraudStage : Swift.Hashable {}
extension AuthMe.ScanDocStatus : Swift.Equatable {}
extension AuthMe.ScanDocStatus : Swift.Hashable {}
extension AuthMe.ScanDocCardType : Swift.Equatable {}
extension AuthMe.ScanDocCardType : Swift.Hashable {}
extension AuthMe.ScanDocCardType : Swift.RawRepresentable {}
